{"pages":[{"title":"404","text":"","path":"404/index.html","date":"10-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-05","excerpt":""}],"posts":[{"title":"闭包","text":"引言闭包的作用 获取函数的内部变量 闭包所产生的作用域包含自身活动对象, 外部函数作用域对象, 和全局变量对象 外部函数在函数返回后被销毁, 但活动对象依旧保留在内存中直到闭包被销毁(销毁方式: function = null) 适用：在动态执行环境中数据会实时发生变化, 为了保持这些非持久型变量, 我们用闭包来作为载体存储 缺点：外部函数调用对象不能释放滥用会使内存泄漏 什么是闭包 有权访问另一个函数作用域中的变量的函数 在另一个函数内部定义的函数会将包含函数(外部函数)的活动对象添加到它的作用域链中, 匿名函数从包含函数中被返回后, 它的作用域链在外部函数执行完毕后其活动对象不会被销毁, 因为匿名函数的作用域链仍在引用这个函数对象, 外部函数的作用域链在函数返回后被销毁, 但他的活动对象依然留在内存中, 直到匿名函数被销毁。function = null 解除对该函数的引用, 等于通知垃圾回收历程将其清除, 匿名函数的作用域链被销毁, 其他作用域(除了全局作用域)也都可以安全的销毁了。 12345678910111213function creatComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; console.log(value1, value2); &#125;&#125;//创建函数var compareNames = creatComparisonFunction('name');//调用函数compareNames(&#123;name: 'hello'&#125;, &#123;name:'world'&#125;);//解除引用compareNames = null; 上面代码在在全局作用域中的关系如下图所示 在匿名函数从createComparisonFunction()中被 返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁","path":"2018/10/10/闭包/","date":"10-10","excerpt":"","preview":"imgs/preview/preview2.jpg"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/10/05/hello-world/","date":"10-05","excerpt":"","preview":"imgs/preview/preview2.jpg"}]}